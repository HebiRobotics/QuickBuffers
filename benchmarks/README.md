# RoboBuffers - Benchmarks
  
Below is a comparison with Google's official bindings for a variety of datasets. The performance depends a lot on the specific data format and content, so the results may not be representative for your use case. All tests were run using JMH on JDK8 on an Intel NUC8i7BEH.

## Benchmark 1 - SBE dataset

The first benchmark was copied from [Small Binary Encoding's](https://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html) Car (140 byte) and MarketData (64 byte) throughput benchmarks. It tests manual creation of messages and encodes and decodes them from a byte array, which is similar to sending and receiving individual messages.

<!-- car mutliplier: 140 * 1000 / (1024*1024) = 0.1335 = -->
<!-- market multiplier: 64 * 1000 / (1024*1024) = 0.061 = -->

| Test [msg/ms] | RoboBuffers | Protobuf-Java | Ratio
| :----------- | :-----------: | :-----------: | :-----------: |
| Car Encode  | 2854 (381 MB/s) | 1125 (150 MB/s) |  2.5  
| Car Decode  | 2042 (273 MB/s) | 1166s (149 MB/s) |  1.8  
| Market Data Encode  | 8267 (504 MB/s) | 3712 (226 MB/s) |  2.2  
| Market Data Decode  | 6357 (388 MB/s) | 3282 (200 MB/s) |  1.9  

Note that this test was done using the original SBE .proto definitions. If the varint types are changed to a less expensive encoding, e.g., `fixed64/32` instead of `int64/32`, the market data numbers improve by another 10-20%. By additionally inlining the small nested fields it'd result in 3-4x the original message throughput of Protobuf-Java. The choice of type can have a huge impact on the performance.

We also compared the built-in JSON encoding and found that for this particular benchmark the message throughput is roughly the same as Protobuf-Java. However, at 559 byte (car) and 435 byte (market) the uncompressed binary sizes are significantly larger.

| Test [msg/ms] | RoboBuffers (JSON) | Protobuf-Java (Binary) | Ratio
| :----------- | :-----------: | :-----------: | :-----------: |
| Car Encode  | 1424 | 1125 |  1.3  
| Market Data Encode  | 3284 | 3712 |  0.9 

## Benchmark 2 - File Streams

We also ran benchmarks for reading and writing streams of delimited protobuf messages with varying contents, which is similar to reading sequentially from a log file. All datasets were loaded into memory and decoded from a byte array. Neither benchmark triggers Protobuf-Java's lazy-parsing of strings, so the results may be slightly off. The benchmark code can be found in the `benchmarks` directory.

|  | RoboBuffers<p>(Unsafe) | RoboBuffers<p>(without Unsafe) | Java`[1]`| JavaLite`[1]` | `[2]`
| ----------- | -----------: | -----------: | -----------: | -----------: | ----------- |
| **Read**  | | 
| 1  | 173ms (502 MB/s) | 212ms (410 MB/s) |  344ms (253 MB/s)  | 567ms (153 MB/s) | 2.0
| 2  | 102ms (559 MB/s)` | 118ms (483 MB/s) | 169ms (337 MB/s)  | 378ms (150 MB/s) | 1.7
| 3  | 34ms (297 MB/s) | 44ms (226 MB/s) | 65ms (153 MB/s)  | 147ms (68 MB/s) | 1.9
| 4  | 25ms (400 MB/s) | 28ms (353 MB/s) | 47ms (214 MB/s)  | 155ms (65 MB/s) | 1.9
| 5 | 9.8ms (6.5 GB/s) | 44ms (1.5 GB/s) |  103ms (621 MB/s)  | 92ms (696 MB/s) | 10.5
|  **Write**`[3]`  | | |
| 1 | 118ms (737 MB/s)  | 165ms (527 MB/s) | 157ms (554 MB/s)  | 718ms (121 MB/s)  | 1.3
| 2 | 71ms (802 MB/s)  | 101ms (564 MB/s) | 137ms (416 MB/s)  | 308ms (188 MB/s) | 1.9
| 3  | 23ms (435 MB/s) | 29ms (344 MB/s) | 29ms (344 MB/s)  | 101ms (99 MB/s) | 1.3
| 4  | 16ms (625 MB/s) | 23ms (434 MB/s) | 42ms (238 MB/s)  | 97ms (103 MB/s) | 2.6
| 5 | 6.2ms (10 GB/s)  | 46ms (1.4 GB/s) | 16ms (4.0 GB/s)  | 21ms (3.0 GB/s) | 2.5
| **Read + Write** |  | 
| 1  | 291ms (299 MB/s) | 377ms (231 MB/s) | 501ms (174 MB/s)  | 1285 ms (68 MB/s) | 1.7
| 2 | 173ms (329 MB/s) | 219ms (260 MB/s) | 306ms (186 MB/s)  | 686 ms (83 MB/s) | 1.8
| 3  | 57ms (176 MB/s) | 73ms (138 MB/s) | 94ms (106 MB/s)  | 248ms (40 MB/s) | 1.6
| 4  | 41ms (244 MB/s) | 51ms (196 MB/s) | 89ms (112 MB/s)  | 252ms (40 MB/s) | 2.2
| 5  | 16ms (4.0 GB/s) | 90ms (711 MB/s) | 119ms (537 MB/s)  | 113ms (566 MB/s) | 7.4

<!-- | 3  | ms (  MB/s) | ms (  MB/s) | ms (  MB/s)  | ms (  MB/s) | 0 -->

* `[1]` Version 3.9.1 (makes use of `sun.misc.Unsafe` when available)
* `[2]` `Java / RoboBuffers (Unsafe)`
* `[3]` Derived from `Write = ((Read + Write) - Read)` which is not necessarily composable

 * Dataset Contents
   * Dataset 1 (87 MB) contains a series of delimited ~220 byte messages (production data). A lot of **scalar data types** and a relatively small amount of nesting. No strings, repeated, or unknown fields. Only a small subset of fields is populated.
   * Dataset 2 (57 MB) contains a series of delimited ~650 byte messages (**production data**). Similar data to dataset 1, but with strings (mostly small and ascii) and more nesting. No unknown or repeated fields. Only about half the fields are populated.
   * Dataset 3 (10 MB) contains ~147k messages generated by the **CarBenchmark**
   * Dataset 4 (10 MB) contains ~73k messages generated by the  **MarketDataBenchmark**
   * Dataset 5 (64 MB) contains a single artificial message with one (64 MB) **packed double field** (`repeated double values = 1 [packed=true]`). It only encodes a repeated type with fixed size, so it should be representative of the best-case scenario memory throughput (on little-endian systems this can map to memcpy).
   
## Benchmark 3 - FlatBuffers
   
We also compared RoboBuffers against the Java bindings of Google's [FlatBuffers](https://google.github.io/flatbuffers/) project and ported its [official C++ benchmark](https://google.github.io/flatbuffers/flatbuffers_benchmarks.html).
   
   
|  | RoboBuffers | FlatBuffers (v1.11.0) | FlatBuffers (v1.10.0) | Ratio`[1]`
| :----------- | :-----------: | :-----------: | :-----------: | :-----------: |
| **UnsafeSource / DirectByteBuffer [ns/op]**  
| Decode             | 292 | 0 | 0 |  0.0 
| Traverse           | 17 | 234 | 321 |  13.8
| Encode             | 312 | 457 | 649 |  1.5
| Encode + Decode + Traverse | 621 | 691 | 970 |  1.1
| **ArraySource / HeapByteBuffer [ns/op]**  
| Decode             | 379 | 0 | 0 |  0.0  
| Traverse           | 29 | 381 | 427 |  13.1
| Encode             | 334 | 626 | 821 |  1.9
| Encode + Decode + Traverse | 742 | 1007 | 1248 |  1.4
| **Other**  
| Serialized Size   | 228 bytes | 344 bytes | 344 bytes |  1.5
| Transient memory allocated during decode   | 0 bytes | 0 bytes | 0 bytes | 1

* `[1]` `FlatBuffers v1.11.0 / RoboBuffers`
* `[2]` `Traverse = (Decode + Traverse) - Decode`
   
While the official C++ benchmark shows tremendous performance benefits over Protobuf, the Java implementation has unfortunately been lagging behind a bit. Recent versions have seen some significant performance improvements, but encoding and traversing a `ByteBuffer` still results in more overhead than may be expected.

Also be aware that the benchmark was created with a bias for FlatBuffers. The original data is mostly comprised of large varint numbers (e.g. a 10 byte int64) and repeated messages with multiple levels of nesting, which is a particularly bad case for Protobuf. Messages with a flatter hierarchy and more fixed-size scalar types should fare much better.